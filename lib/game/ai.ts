/**
 * generated by chatGPT 5
 * why use this file and game/engine.ts?
 * Per chatGPT: for move selection, an LLM (OpenAI/Claude) is the wrong tool. You’ll get higher strength, lower cost, and lower latency with classic game-AI (what you already have): minimax + alpha-beta, better heuristics, transposition tables, and deeper search (possibly in a Web Worker). That’s what “real” game AIs use.
 */
import {
  Board,
  Player,
  COLS,
  ROWS,
  applyMove,
  checkWin,
  isDraw,
  playerToCell,
  nextPlayer,
} from '@/lib/game/engine';

const ORDER = [3, 2, 4, 1, 5, 0, 6] as const;

/** Difficulty → search depth */
export function depthForDifficulty(d: 1 | 2 | 3) {
  return d === 1 ? 3 : d === 2 ? 5 : 7;
}

/** Return best column for the given player (AI) using minimax + alpha-beta. */
export function aiBestMove(
  board: Board,
  current: Player,
  aiPlayer: Player,
  depth: number
): number {
  // First: if AI can win now, do it.
  const winCol = findImmediateWin(board, aiPlayer);
  if (winCol !== -1) return winCol;

  // Second: if opponent can win next, block it.
  const blockCol = findImmediateBlock(board, aiPlayer);
  if (blockCol !== -1) return blockCol;

  // Otherwise, search normally (negamax + alpha-beta).
  let bestCol: number = ORDER[0];
  let bestScore = -Infinity;

  for (const col of ORDER) {
    try {
      const { board: b2, row, col: c2 } = applyMove(board, col, current);
      const win = checkWin(b2, row, c2);
      const score =
        win && win.winner === aiPlayer
          ? Infinity
          : -negamax(
              b2,
              nextPlayer(current),
              aiPlayer,
              depth - 1,
              -Infinity,
              Infinity
            );
      if (score > bestScore) {
        bestScore = score;
        bestCol = col;
      }
    } catch {
      /* column full */
    }
  }
  return bestCol;
}

export function aiChooseMove(
  board: Board,
  current: Player,
  aiPlayer: Player,
  difficulty: 1 | 2 | 3
): number {
  // 1) Force tactical sanity
  const winCol = findImmediateWin(board, aiPlayer);
  if (winCol !== -1) return winCol;
  const blockCol = findImmediateBlock(board, aiPlayer);
  if (blockCol !== -1) return blockCol;

  // 2) Depth by difficulty
  const depth = depthForDifficulty(difficulty);

  // 3) Score all legal moves (negamax); keep columns + scores
  const scored: Array<{ col: number; score: number }> = [];
  for (const col of ORDER) {
    try {
      const { board: b2, row, col: c2 } = applyMove(board, col, current);
      const win = checkWin(b2, row, c2);
      const score =
        win && win.winner === aiPlayer
          ? Infinity
          : -negamax(
              b2,
              nextPlayer(current),
              aiPlayer,
              depth - 1,
              -Infinity,
              Infinity
            );
      scored.push({ col, score });
    } catch {
      /* column full */
    }
  }
  if (scored.length === 0) return 3; // fallback (shouldn't happen)

  // 4) Pick by difficulty
  // Hard = strict best; Medium = best (deterministic);
  // Easy = softmax among top 2-3 so it feels human.
  scored.sort((a, b) => b.score - a.score);

  if (difficulty === 1) {
    const topK = scored.slice(0, Math.min(3, scored.length));
    return softmaxPick(topK, 0.6);
  }

  // Medium / Hard → best
  return scored[0].col;
}

function softmaxPick(
  cols: Array<{ col: number; score: number }>,
  temperature = 0.6
): number {
  // normalize scores to [0,1] range to avoid overflow
  const max = Math.max(...cols.map((c) => c.score));
  const min = Math.min(...cols.map((c) => c.score));
  const norm = cols.map((c) => ({
    col: c.col,
    s: max === min ? 0.5 : (c.score - min) / (max - min),
  }));
  const weights = norm.map(({ s }) =>
    Math.exp(s / Math.max(0.05, temperature))
  );
  const total = weights.reduce((a, b) => a + b, 0);
  let r = Math.random() * total;
  for (let i = 0; i < cols.length; i++) {
    r -= weights[i];
    if (r <= 0) return cols[i].col;
  }
  return cols[0].col;
}

// Return a winning column for `player` this move, or -1 if none.
function findImmediateWin(board: Board, player: Player): number {
  for (const col of ORDER) {
    try {
      const { board: b2, row, col: c2 } = applyMove(board, col, player);
      const win = checkWin(b2, row, c2);
      if (win && win.winner === player) return col;
    } catch {
      /* column full */
    }
  }
  return -1;
}

// Return a blocking column (opponent can win next move), or -1 if no threat.
function findImmediateBlock(board: Board, aiPlayer: Player): number {
  const opp = nextPlayer(aiPlayer);
  for (const col of ORDER) {
    try {
      const { board: b2, row, col: c2 } = applyMove(board, col, opp);
      const win = checkWin(b2, row, c2);
      if (win && win.winner === opp) return col; // block here now
    } catch {
      /* column full */
    }
  }
  return -1;
}

/** Negamax (minimax variant) with alpha-beta pruning */
function negamax(
  board: Board,
  current: Player,
  aiPlayer: Player,
  depth: number,
  alpha: number,
  beta: number
): number {
  // quick terminal checks from any last move perspective:
  // we don't know last move; so evaluate terminal by scanning all cells cheaply
  const term = terminalScore(board, aiPlayer);
  if (term !== null) return term;
  if (depth === 0) return heuristic(board, aiPlayer);

  let maxScore = -Infinity;

  for (const col of ORDER) {
    try {
      const { board: b2, row, col: c2 } = applyMove(board, col, current);
      const win = checkWin(b2, row, c2);
      const score = win
        ? win.winner === aiPlayer
          ? Infinity
          : -Infinity
        : -negamax(b2, nextPlayer(current), aiPlayer, depth - 1, -beta, -alpha);

      if (score > maxScore) maxScore = score;
      if (maxScore > alpha) alpha = maxScore;
      if (alpha >= beta) break; // prune
    } catch {
      /* full */
    }
  }
  return maxScore;
}

/** Terminal: +∞ if AI already won, -∞ if AI lost, 0 for draw; otherwise null. */
function terminalScore(board: Board, aiPlayer: Player): number | null {
  // scan all 4-in-a-row windows for a win
  const ai = playerToCell(aiPlayer);
  const opp = playerToCell(nextPlayer(aiPlayer));

  if (hasConnect4(board, ai)) return Infinity;
  if (hasConnect4(board, opp)) return -Infinity;
  if (isDraw(board)) return 0;
  return null;
}

/** Heuristic: center bias + 2/3-in-a-row scores; opponent blocking penalties. */
function heuristic(board: Board, aiPlayer: Player): number {
  const ai = playerToCell(aiPlayer);
  const opp = playerToCell(nextPlayer(aiPlayer));

  let score = 0;

  // center column preference
  const centerCol = Math.floor(COLS / 2);
  for (let r = 0; r < ROWS; r++) {
    if (board[r][centerCol] === ai) score += 4;
  }

  // score all 4-length windows
  const windows = enumerateWindows(board);
  for (const win of windows) {
    const a = win.filter((v) => v === ai).length;
    const o = win.filter((v) => v === opp).length;
    const e = win.filter((v) => v === 0).length;

    if (a === 4) score += 100000;
    else if (a === 3 && e === 1) score += 100;
    else if (a === 2 && e === 2) score += 10;

    if (o === 3 && e === 1) score -= 80; // block their threes
    else if (o === 2 && e === 2) score -= 6;
  }
  return score;
}

function hasConnect4(board: Board, disc: 0 | 1 | 2): boolean {
  // horizontal
  for (let r = 0; r < ROWS; r++)
    for (let c = 0; c < COLS - 3; c++)
      if (
        lineEq(
          board[r][c],
          board[r][c + 1],
          board[r][c + 2],
          board[r][c + 3],
          disc
        )
      )
        return true;

  // vertical
  for (let c = 0; c < COLS; c++)
    for (let r = 0; r < ROWS - 3; r++)
      if (
        lineEq(
          board[r][c],
          board[r + 1][c],
          board[r + 2][c],
          board[r + 3][c],
          disc
        )
      )
        return true;

  // diag ↘
  for (let r = 0; r < ROWS - 3; r++)
    for (let c = 0; c < COLS - 3; c++)
      if (
        lineEq(
          board[r][c],
          board[r + 1][c + 1],
          board[r + 2][c + 2],
          board[r + 3][c + 3],
          disc
        )
      )
        return true;

  // diag ↙
  for (let r = 3; r < ROWS; r++)
    for (let c = 0; c < COLS - 3; c++)
      if (
        lineEq(
          board[r][c],
          board[r - 1][c + 1],
          board[r - 2][c + 2],
          board[r - 3][c + 3],
          disc
        )
      )
        return true;

  return false;
}

function lineEq(a: number, b: number, c: number, d: number, disc: number) {
  return a === disc && b === disc && c === disc && d === disc;
}

function enumerateWindows(board: Board): number[][] {
  const wins: number[][] = [];

  // horizontal
  for (let r = 0; r < ROWS; r++)
    for (let c = 0; c < COLS - 3; c++)
      wins.push([
        board[r][c],
        board[r][c + 1],
        board[r][c + 2],
        board[r][c + 3],
      ]);

  // vertical
  for (let c = 0; c < COLS; c++)
    for (let r = 0; r < ROWS - 3; r++)
      wins.push([
        board[r][c],
        board[r + 1][c],
        board[r + 2][c],
        board[r + 3][c],
      ]);

  // diag ↘
  for (let r = 0; r < ROWS - 3; r++)
    for (let c = 0; c < COLS - 3; c++)
      wins.push([
        board[r][c],
        board[r + 1][c + 1],
        board[r + 2][c + 2],
        board[r + 3][c + 3],
      ]);

  // diag ↙
  for (let r = 3; r < ROWS; r++)
    for (let c = 0; c < COLS - 3; c++)
      wins.push([
        board[r][c],
        board[r - 1][c + 1],
        board[r - 2][c + 2],
        board[r - 3][c + 3],
      ]);

  return wins;
}
